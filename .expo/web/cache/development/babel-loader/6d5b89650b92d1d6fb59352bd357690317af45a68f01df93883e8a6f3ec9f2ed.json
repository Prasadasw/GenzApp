{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport { useState } from 'react';\nimport { getTruthQuestions, getDareChallenges } from \"../data/truth-or-dare-data\";\nexport function useTruthOrDare() {\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    currentChallenge = _useState2[0],\n    setCurrentChallenge = _useState2[1];\n  var _useState3 = useState([]),\n    _useState4 = _slicedToArray(_useState3, 2),\n    completedChallenges = _useState4[0],\n    setCompletedChallenges = _useState4[1];\n  var _useState5 = useState([]),\n    _useState6 = _slicedToArray(_useState5, 2),\n    skippedChallenges = _useState6[0],\n    setSkippedChallenges = _useState6[1];\n  var generateChallenge = function generateChallenge(type) {\n    var challenges = type === 'truth' ? getTruthQuestions() : getDareChallenges();\n    var availableChallenges = challenges.filter(function (challenge) {\n      return !completedChallenges.includes(challenge);\n    });\n    if (availableChallenges.length === 0) {\n      setCompletedChallenges([]);\n      setCurrentChallenge(challenges[Math.floor(Math.random() * challenges.length)]);\n    } else {\n      setCurrentChallenge(availableChallenges[Math.floor(Math.random() * availableChallenges.length)]);\n    }\n  };\n  var completeChallenge = function completeChallenge() {\n    if (currentChallenge) {\n      setCompletedChallenges([].concat(_toConsumableArray(completedChallenges), [currentChallenge]));\n    }\n  };\n  var skipChallenge = function skipChallenge() {\n    if (currentChallenge) {\n      setSkippedChallenges([].concat(_toConsumableArray(skippedChallenges), [currentChallenge]));\n    }\n  };\n  return {\n    currentChallenge: currentChallenge,\n    generateChallenge: generateChallenge,\n    completeChallenge: completeChallenge,\n    skipChallenge: skipChallenge\n  };\n}","map":{"version":3,"names":["useState","getTruthQuestions","getDareChallenges","useTruthOrDare","_useState","_useState2","_slicedToArray","currentChallenge","setCurrentChallenge","_useState3","_useState4","completedChallenges","setCompletedChallenges","_useState5","_useState6","skippedChallenges","setSkippedChallenges","generateChallenge","type","challenges","availableChallenges","filter","challenge","includes","length","Math","floor","random","completeChallenge","concat","_toConsumableArray","skipChallenge"],"sources":["C:/Users/Adarsh/Desktop/GenzApp/src/hooks/useTruthOrDare.ts"],"sourcesContent":["import { useState } from 'react';\r\nimport { getTruthQuestions, getDareChallenges } from '../data/truth-or-dare-data';\r\n\r\nexport function useTruthOrDare() {\r\n  const [currentChallenge, setCurrentChallenge] = useState<string | null>(null);\r\n  const [completedChallenges, setCompletedChallenges] = useState<string[]>([]);\r\n  const [skippedChallenges, setSkippedChallenges] = useState<string[]>([]);\r\n\r\n  const generateChallenge = (type: 'truth' | 'dare') => {\r\n    const challenges = type === 'truth' ? getTruthQuestions() : getDareChallenges();\r\n    const availableChallenges = challenges.filter(\r\n      challenge => !completedChallenges.includes(challenge)\r\n    );\r\n    \r\n    if (availableChallenges.length === 0) {\r\n      setCompletedChallenges([]); // Reset if all challenges are used\r\n      setCurrentChallenge(challenges[Math.floor(Math.random() * challenges.length)]);\r\n    } else {\r\n      setCurrentChallenge(\r\n        availableChallenges[Math.floor(Math.random() * availableChallenges.length)]\r\n      );\r\n    }\r\n  };\r\n\r\n  const completeChallenge = () => {\r\n    if (currentChallenge) {\r\n      setCompletedChallenges([...completedChallenges, currentChallenge]);\r\n    }\r\n  };\r\n\r\n  const skipChallenge = () => {\r\n    if (currentChallenge) {\r\n      setSkippedChallenges([...skippedChallenges, currentChallenge]);\r\n    }\r\n  };\r\n\r\n  return {\r\n    currentChallenge,\r\n    generateChallenge,\r\n    completeChallenge,\r\n    skipChallenge,\r\n  };\r\n}"],"mappings":";;AAAA,SAASA,QAAQ,QAAQ,OAAO;AAChC,SAASC,iBAAiB,EAAEC,iBAAiB;AAE7C,OAAO,SAASC,cAAcA,CAAA,EAAG;EAC/B,IAAAC,SAAA,GAAgDJ,QAAQ,CAAgB,IAAI,CAAC;IAAAK,UAAA,GAAAC,cAAA,CAAAF,SAAA;IAAtEG,gBAAgB,GAAAF,UAAA;IAAEG,mBAAmB,GAAAH,UAAA;EAC5C,IAAAI,UAAA,GAAsDT,QAAQ,CAAW,EAAE,CAAC;IAAAU,UAAA,GAAAJ,cAAA,CAAAG,UAAA;IAArEE,mBAAmB,GAAAD,UAAA;IAAEE,sBAAsB,GAAAF,UAAA;EAClD,IAAAG,UAAA,GAAkDb,QAAQ,CAAW,EAAE,CAAC;IAAAc,UAAA,GAAAR,cAAA,CAAAO,UAAA;IAAjEE,iBAAiB,GAAAD,UAAA;IAAEE,oBAAoB,GAAAF,UAAA;EAE9C,IAAMG,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIC,IAAsB,EAAK;IACpD,IAAMC,UAAU,GAAGD,IAAI,KAAK,OAAO,GAAGjB,iBAAiB,CAAC,CAAC,GAAGC,iBAAiB,CAAC,CAAC;IAC/E,IAAMkB,mBAAmB,GAAGD,UAAU,CAACE,MAAM,CAC3C,UAAAC,SAAS;MAAA,OAAI,CAACX,mBAAmB,CAACY,QAAQ,CAACD,SAAS,CAAC;IAAA,CACvD,CAAC;IAED,IAAIF,mBAAmB,CAACI,MAAM,KAAK,CAAC,EAAE;MACpCZ,sBAAsB,CAAC,EAAE,CAAC;MAC1BJ,mBAAmB,CAACW,UAAU,CAACM,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGR,UAAU,CAACK,MAAM,CAAC,CAAC,CAAC;IAChF,CAAC,MAAM;MACLhB,mBAAmB,CACjBY,mBAAmB,CAACK,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGP,mBAAmB,CAACI,MAAM,CAAC,CAC5E,CAAC;IACH;EACF,CAAC;EAED,IAAMI,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAA,EAAS;IAC9B,IAAIrB,gBAAgB,EAAE;MACpBK,sBAAsB,IAAAiB,MAAA,CAAAC,kBAAA,CAAKnB,mBAAmB,IAAEJ,gBAAgB,EAAC,CAAC;IACpE;EACF,CAAC;EAED,IAAMwB,aAAa,GAAG,SAAhBA,aAAaA,CAAA,EAAS;IAC1B,IAAIxB,gBAAgB,EAAE;MACpBS,oBAAoB,IAAAa,MAAA,CAAAC,kBAAA,CAAKf,iBAAiB,IAAER,gBAAgB,EAAC,CAAC;IAChE;EACF,CAAC;EAED,OAAO;IACLA,gBAAgB,EAAhBA,gBAAgB;IAChBU,iBAAiB,EAAjBA,iBAAiB;IACjBW,iBAAiB,EAAjBA,iBAAiB;IACjBG,aAAa,EAAbA;EACF,CAAC;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}